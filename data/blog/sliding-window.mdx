---
title: 'Sliding Window Algorithms'
date: 2022-06-09T20:00:14Z
lastmod: '2022-06-09'
tags: ['algorithms', 'javascript']
draft: false
summary: 'A look into sublists'
---

## Intro

The sliding window approach is a pretty simple algorithm to handle calculating data within a sublist.

## Ex 1:

Given a list of numbers, find the largest sum of any sublist.

```javascript
const max_sub_array_of_size_k = function (k, arr) {
  let max = 0, // max sum of sublist of size k
    current = 0, // current sum of sublist of size k
    start = 0 // start position of the sublist (or window)

  for (end = 0; end < arr.length; end++) {
    current += arr[end] // First, add the current element to the current sum

    if (end >= k - 1) {
      // If the window is full, then we can calculate the max sum
      max = Math.max(max, current)
      current -= arr[start] // Subtract the first element of the window
      start++ // Move the start position of the window
    }
  }
  return max
}
```

Complexity: O(n)

---

## Ex 2:

Given an array of positive numbers, find the smallest subarray with a sum greater or equal to a given value.

```javascript
const smallest_subarray_sum = function (s, arr) {
  let minLength = Infinity,
    start = 0, // start position of the sublist (or window)
    total = 0 // current sum of sublist

  for (end = 0; end < arr.length; end++) {
    total += arr[end] // First, add the current element to the current sum
    // We want this to be a while loop so we go through every item in the array.
    while (total >= s) {
      minLength = Math.min(minLength, end - start + 1) // Array width is the window end (end) - the start, plus 1 (to get the actual length between two indices)
      total -= arr[start] // Subtract the first element of the window so we can slide the window over
      start++ // Move the start position of the window
    }
  }
  if (minLength === Infinity) {
    minLength = 0
  }
  return minLength
}
```

Complexity: O(n)

---

## Ex 3:

Find the longest substring with no more than K distinct characters.

```javascript
const longest_substring_with_k_distinct = function (str, k) {
  let start = 0,
    maxLength = 0,
    charMap = {}

  for (let end = 0; end < str.length; end++) {
    const rightChar = str[end]
    if (!(rightChar in charMap)) {
      charMap[rightChar] = 0
    }
    charMap[rightChar] += 1

    // Only start removing characters from the start if the length is more than the max
    while (Object.keys(charMap).length > k) {
      const leftChar = str[start]
      charMap[leftChar] -= 1
      if (charMap[leftChar] === 0) {
        delete charMap[leftChar]
      }
      start += 1
    }

    maxLength = Math.max(maxLength, end - start + 1)
  }
  return maxLength
}
```

## Ex 4:

Given an array of characters where each character represents a fruit tree, you are given two baskets and your goal is to put maximum number of fruits in each basket. The only restriction is that each basket can have only one type of fruit.
You can start with any tree, but once you have started you canâ€™t skip a tree. You will pick one fruit from each tree until you cannot, i.e., you will stop when you have to pick from a third fruit type.
Write a function to return the maximum number of fruits in both the baskets.

This is just another version of the "Longest Substring with at most 2 distinct characters" problem.

```javascript
const get_max_number_of_fruits = function (fruit) {
  let start = 0,
    end = 0
  let maxLength = 0
  let fruitMap = {}

  // Add each of the fruit to the fruitmap
  while (end < fruit.length) {
    const rightFruit = fruit[end]
    if (!(rightFruit in fruitMao)) {
      fruitMap[rightFruit] = 0
    }
    fruitMap[rightFruit] += 1

    // Once the map gets larger than 2, we need to remove the leftmost fruit until there are only 2 fruits in the map
    while (Objects.keys(fruitMap).length > 2) {
      const leftFruit = fruit[start]
      fruitMap[(leftFruit -= 1)]
      if (fruitMap[leftFruit] === 0) {
        delete fruitMap[leftFruit]
      }
      start += 1
    }
    maxLength = Math.max(maxLength, end - start + 1)
    end += 1
  }
}
```

# Ex 5:

Longest Repeating Character Replacement

You are given a string of uppercase letters (s) and an integer (k). You can choose any character of the string and change it to any other uppercase English character.
You can perform this operation at most k times.

```javascript
var characterReplacement = function (s, k) {
  let left = 0,
    right = 0,
    maxLength = 0,
    mostFreq = 0,
    charMap = {}

  // Move the right pointer towards the end of the array
  while (right < s.length) {
    charMap[s[right]] = charMap[s[right]] + 1 || 1
    mostFreq = Math.max(charMap[s[right]], mostFreq)

    while (right - left + 1 - mostFreq > k) {
      charMap[s[left]]--
      left++
    }

    maxLength = Math.max(right - left + 1, maxLength)
    right++
  }
  return maxLength
}
```

Complexity: O(n)

## Ex 6:

(Best Time to Buy and Sell Stock)[https://leetcode.com/problems/best-time-to-buy-and-sell-stock/]

You are given an array prices where prices[i] is the price of a given stock on the ith day.

You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.

Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        l, r = 0, 1
        max_num = 0

        while r < len(prices):
            # Move the window over if the right side is higher than the left
            if prices[r] < prices[l]:
                l = r
            max_num = max(max_num, prices[r] - prices[l])
            r += 1

        return max_num
```
